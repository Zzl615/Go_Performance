## sync.Pool

#### 一、使用场景：

保存和复用临时对象，**减少内存分配，降低 GC 压力**。短时间内需要创建**大量的临时对象**，都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。使用和放回、异常处理

#### 二、 原理

sync.Pool 是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool 的大小是可伸缩的，高负载时会动态扩容，存放在池中的对象如果不活跃了会被自动清理。

sync.Pool 用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻 GC 的压力，从而提升系统的性能。

在这个例子中，因为 Student 结构体内存占用较小，内存分配几乎不耗时间。而**标准库 json 反序列化时利用了反射，效率是比较低的，占据了大部分时间，因此两种方式最终的执行时间几乎没什么变化**。但是内存占用差了一个数量级，使用了 `sync.Pool` 后，内存占用仅为未使用的 234/5096 = 1/22，对 GC 的影响就很大了。

Go 语言标准库也大量使用了 `sync.Pool`，例如 `fmt` 和 `encoding/json`。`fmt.Printf` 的调用是非常频繁的，利用 `sync.Pool` 复用 pp 对象能够极大地提升性能，减少内存占用，同时降低 GC 压力。

## sync.Once

#### 一、使用场景：

**Go 标准库，提供的使函数只执行一次的实现**，常应用于**单例模式**。例如初始化配置、保持数据库连接等。与 `init` 函数类似，但有区别：

- init 函数是当所在的 **package 首次被加载时执行**，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。
- sync.Once 可以在代码的**任意位置初始化和调用**，因此**可以延迟到使用时再执行**，并发场景下是线程安全的。

`sync.Once` 被用于控制变量的初始化，当且仅当第一次访问某个变量时，进行初始化（写）；变量初始化过程中，所有读都被阻塞，直到初始化完成；变量仅初始化一次，初始化完成后驻留在内存里。

#### 二、 原理

**`sync.Once` 使用 `done` 标记是否已经初始化，使用锁 `m Mutex` 实现线程安全，支持并发。**

Pro1：为什么将 done 置为 Once 的第一个字段？

- 第1点：done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能。
  
- 第2点：因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。如果是其他的字段，除了结构体指针外，还需要计算与第一个值的偏移(calculate offset)。
  
- 第3点：在机器码中，偏移量是随指令传递的附加值，CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因为，访问第一个字段的机器代码更紧凑，速度更快。

## sync.Cond

#### 一、使用场景：

用在多个 goroutine 等待接收完读取数据，一个 goroutine 在异步地接收数据，发送通知的场景。单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据。

#### 二、 实现原理

用一个**全局的变量来标志第一个协程数据是否接受完毕**，剩下的协程，反复简单该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。