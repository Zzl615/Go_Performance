# 并发编程

## 超时控制的陷阱

超时控制在网络编程中是非常的操作。

使用 `context.WithTimeout` 和 `time.After` 都能够很轻易地实现

`time.After` 启动了一个异步的定时器，返回一个 channel，当超过指定的时间后，该 channel 将会接受到信号

- 启动了子协程执行函数 f，函数执行结束后，将向 channel `done` 发送结束信号。
- 使用 select 阻塞等待 `done` 或 `time.After` 的信息，若超时，则返回错误，若没有超时，则返回 nil。

协程无法退出，随着时间的积累，造成内存耗尽，程序崩溃

#### 有可能在超时的时候，强制kill goroutine可能吗？

goroutine 被设计为不可以从外部无条件地结束掉，只能通过 channel 来与它通信。也就是说，每一个 goroutine 都需要承担自己退出的责任。(A goroutine cannot be programmatically killed. It can only commit a cooperative suicide.)

#### 关于通道和协程的垃圾回收

注意，一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。事实上，一个协程只有在退出后才能被垃圾回收。


## 通道关闭的陷阱

#### 一、 channel 的三种状态和三种操作结果

| 操作  | 空值(nil) | 非空已关闭 | 非空未关闭 |
| --- | --- | --- | --- |
| 关闭  | panic | panic | 成功关闭 |
| 发送数据 | 永久阻塞 | panic | 阻塞或成功发送 |
| 接收数据 | 永久阻塞 | 永不阻塞 | 阻塞或者成功接收 |

#### 二、通道关闭原则

一个常用的使用Go通道的原则是不要在数据接收方或者在有多个发送者的情况下关闭通道。换句话说，我们**只应该让一个通道唯一的发送者关闭此通道**。如果 channel 已经被关闭，再次关闭会产生 panic。

#### 三、优雅的方式

- 情形一：M个接收者和一个发送者，发送者通过关闭用来传输数据的通道来传递发送结束信号。
- 情形二：一个接收者和N个发送者，此唯一接收者通过关闭一个额外的信号通道来通知发送者不要再发送数据了。
- 情形三：M个接收者和N个发送者，它们中的任何协程都可以让一个中间调解协程帮忙发出停止数据传送的信号。


## 控制协程(goroutine)的并发数量

#### 一、原因

系统的资源是有限的。

- 对单个 file/socket 的并发操作个数超过了系统上限
  
- 每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 2GB，那么至多允许 2GB/2KB = 1M 个协程同时存在。
  

#### 二、解决方法：

##### 1. 利用 channel 的缓存区，

- `make(chan struct{}, 3)` 创建缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 3 个消息则被阻塞。
- 开启协程前，调用 `ch <- struct{}{}`，若缓存区满，则阻塞。
- 协程任务结束，调用 `<-ch` 释放缓冲区。
- `sync.WaitGroup` 并不是必须的，例如 http 服务，每个请求天然是并发的，此时使用 channel 控制并发处理的任务数量，就不需要 `sync.WaitGroup`。

##### 2.使用协程池，制协程的并发数量

- [Jeffail/tunny](https://github.com/Jeffail/tunny)
- [panjf2000/ants](https://github.com/panjf2000/ants)